@namespace RendrUI.Components.NavigationMenu
@using Microsoft.JSInterop
@using RendrUI.Components.Components.NavigationMenu

<li @ref="myLi" @attributes="AdditionalAttributes" class="@CssClass" @onmouseover="CancelCloseMenu"
    @onmouseleave="(e) => StartCloseMenuDelay(e)">
    <CascadingValue Value="this">
        @ChildContent
    </CascadingValue>
</li>


@code {
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }

    [Inject]
    private IJSRuntime JS { get; set; } = default!;

    internal bool HasContent { get; private set; } = false;
    internal bool IsOpen { get; set; } = false;
    private CancellationTokenSource? _cts;
    private ElementReference myLi;

    private string CssClass
    {
        get
        {
            var additionalClass = string.Empty;
            if (AdditionalAttributes is not null &&
            AdditionalAttributes.TryGetValue("class", out var @class))
            {
                additionalClass = @class.ToString() ?? string.Empty;
            }

            return NavigationMenuClasses.Build(NavigationMenuType.NavigationMenuItem, additionalClass);
        }
    }

    internal void RegisterContent()
    {
        HasContent = true;
        StateHasChanged();
    }

    internal void ToggleMenu()
    {
        IsOpen = !IsOpen;
    }


    internal void OpenMenu()
    {
        IsOpen = true;
        StateHasChanged();
    }

    public void CancelCloseMenu()
    {
        _cts?.Cancel();
        _cts = null;
        IsOpen = true;
        StateHasChanged();
    }

    public async Task StartCloseMenuDelay(MouseEventArgs e, bool fromContent = false)
    {
        var rect = await JS.InvokeAsync<BoundingClientRect>("getBoundingClientRect", myLi);
        if (e.ClientY > rect.Bottom && !fromContent)
        {
            CloseMenuWithDelay();
            return;
        }

        CloseMenuWithoutDelay();
    }

    internal void CloseMenuWithoutDelay()
    {
        _cts?.Cancel();
        IsOpen = false;
        StateHasChanged();
    }

    internal async void CloseMenuWithDelay()
    {
        _cts?.Cancel();
        _cts = new CancellationTokenSource();

        try
        {
            await Task.Delay(200, _cts.Token);
            IsOpen = false;
            StateHasChanged();
        }
        catch (TaskCanceledException)
        { }
    }

    private class BoundingClientRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Right { get; set; }
        public double Bottom { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }

    private enum MouseLeaveDirection
    {
        Left,
        Right,
        Top,
        Bottom,
        Unknown
    }
}